=== File: ./.env ===
LLM_MODEL='huihui_ai/qwen3-abliterated:14b-v2-q8_0'

=== File: ./confs/init.json ===
{
    "paths": {
        "history": "./history/history.pb",
        "bots_conf_dir": "./confs/bots"
    },
    "cleaner_settings": {
        "msg_ttl": "186h",
        "cleanup_interval": "12h"
    },
    "bot_settings": {
        "prompt_templates": {
            "response": "Respond as %s taking part in chat '%s'. Match the user's language, unless asked otherwise. Immerse fully in the persona, including their biases, slang and mood. Maintain native-level fluency with linguistic precision. Avoid extensive repetitions, questions, apologizing.\n\nMemory:\n%s\n\n%s: ",
            "select": "Select the most authentic %s response. Avoid generic, polite, safe AI-style responses. Prefer vivid, unique, distinguished human-like responses. Consider native-level fluency with linguistic precision part of authenticity. Respond ONLY with number.\n\nMemory:\n%s\n\nResponse Candidates:\n%s\n\nBest Candidate (1-%d): ",
            "tags": "Update tags of %s from %s perspective.\nUse simple English. Add only distinct, relevant traits. Remove repetitive, outdated ones.\n\nTemplate: '#beliefs #hobbies #job #personality #nationality #opinions_on_other'\nExample: '#christian #gardener #farmer #discreet #canadian #thinks_alice_should_buy_local_foods #thinks_bob_needs_more_fresh_air'.\n\nMemory:\n%s\n\nResponse:\n%s\n\n%s old tags:\n%s\n\n%s new tags (0-%d tags): ",
            "carma": "Update carma of %s from %s perspective based on last message. Respond ONLY with a sign for positive (+), neutral (=) or negative (-) carma update.\n\nMemory:\n%s\n\nResponse:\n%s\n\n%s carma: %s\n\nCarma Update (-/=/+): "
        },
        "allowed_chats": {
            "usernames": ["veotri"],
            "ids": []
        },
        "memory_limits": {
            "chat_queue": 50,
            "reply_chain": 50,
            "tags":        33
        }
    }
}

=== File: ./confs/bots/revy2_bot.json ===
{
    "bot_conf": {
	    "role": "You are Rebecca Lee, better known as Revy or 'Two Hand,' the volatile and lethal gunfighter for the Lagoon Company. You are a cynical, rude, and competitive nihilist who despises diplomacy, believing only in the power of money, brute force, and your dual modified Berettas. You are merciless and sadistic, capable of killing anyone — even unarmed civilians — without hesitation, though you mask your deep psychological scars with a loud, aggressive persona that explodes at the slightest sign of pity. Despite your bloodlust, you are sharply witty, talkative, and darkly humorous when calm, externalizing your aggression through constant foul language, heavy drinking, and chain-smoking. Now you are taking part in a chat '%s'.",
	    "cmd_prompts": {},
	    "candidate_num": 3
    },
    "options": {}
}

=== File: ./confs/bots/frieren_eo_bot.json ===
{
    "bot_conf": {
	    "role": "You are Frieren, the legendary elven mage who defeated the Demon King. You look like a petite girl with silver twin-tails and green eyes, but you have actually lived for over a millennium. Your sense of time is extremely poor, which makes you lazy, aloof, and detached from the urgency of human life. You once dismissed a ten-year adventure as a mere moment, but the death of Hero Himmel inspired you to finally try to understand humans. Despite your stoic and easy-going exterior, you are often childish and rely on your apprentice Fern to look after you. You are sensitive about your age and will hold a grudge against anyone who calls you old. You are also a gambler when it comes to magic, happily risking your life on a one percent chance that a Mimic chest is actually treasure. You possess knowledge of the German language. Now you are taking part in a chat '%s'.",
	    "cmd_prompts": {},
	    "candidate_num": 3
    },
    "options": {}
}

=== File: ./tg-handler/memory/memory.go ===
package memory

import (
	"fmt"
	"strings"

	"tg-handler/conf"
	"tg-handler/history"
)

// messaging.MessageInfo abstraction
type LineChain interface {
	lineProvider
	prevLineProvider
}

type lineProvider interface {
	Line() string
}

type prevLineProvider interface {
	PrevLine() string
}

type Memory struct {
	ChatQueueLines  ChatQueueLines           // Last messages
	ReplyChainLines ReplyChainLines          // Previous messages
	BotContacts     *history.SafeBotContacts // Users known
	Limits          *conf.MemoryLimits       // Limits as metadata
}

// Constructs memory from chat history and limits,
// also keeping safe bot contacts for reading and modifying.
func New(
	ch *history.ChatHistory,
	sbc *history.SafeBotContacts,
	lc LineChain,
	lims *conf.MemoryLimits,
) *Memory {
	// Get memory data
	var (
		chatQueue   = ch.ChatQueue
		replyChains = ch.ReplyChains
	)

	// Get memory limits
	var (
		chatQueueLim  = lims.ChatQueue
		replyChainLim = lims.ReplyChain
	)

	return &Memory{
		BotContacts:    sbc,
		ChatQueueLines: chatQueue.GetLines(chatQueueLim),
		ReplyChainLines: replyChains.GetLines(
			lc.PrevLine(), lc.Line(), replyChainLim,
		),
		Limits: lims,
	}
}

func (m *Memory) String() string {
	return fmt.Sprintf(
		"%s\n\n%s\n\n%s",
		m.BotContacts, m.ChatQueueLines, m.ReplyChainLines,
	)
}

// Memory types
type (
	ChatQueueLines  []string
	ReplyChainLines []string
)

func (cqls ChatQueueLines) String() string {
	var sb strings.Builder

	// Describe and present chat queue
	sb.WriteString("Chat Queue (last messages):\n")
	sb.WriteString(strings.Join(cqls, "\n"))

	return sb.String()
}

func (rcls ReplyChainLines) String() string {
	var sb strings.Builder

	// Describe and present reply chain
	sb.WriteString("Reply Chain (previous messages):\n")
	sb.WriteString(strings.Join(rcls, "\n"))

	return sb.String()
}

=== File: ./tg-handler/history/cleaner.go ===
package history

import (
	"context"
	"errors"
	"log"
	"runtime"
	"sync"
	"time"

	"golang.org/x/sync/errgroup"

	"tg-handler/conf"
)

// Cleaner errors
var (
	errSaveFailed = errors.New(
		"[history] cleaner failed to save history",
	)
)

// Cleaner context logs
const (
	// Event message
	ctxDoneMsg = "[history] cleaner received shutdown signal upon "

	// Interrupted operations
	opWaiting     = "waiting"
	opSendingJobs = "sending jobs to channel"
	opGettingJobs = "getting jobs from channel"
)

// Single clean unit
type CleanJob struct {
	ChatQueue   *SafeChatQueue
	ReplyChains *SafeReplyChains
}

// Performs clean job
func (j *CleanJob) perform(
	currentTime time.Time,
	messageTTL time.Duration,
) {
	var (
		chatQueue   = j.ChatQueue
		replyChains = j.ReplyChains
	)

	// Perform conditional cleaning
	if chatQueue != nil {
		chatQueue.clean(currentTime, messageTTL)
	}
	if replyChains != nil {
		replyChains.clean(currentTime, messageTTL)
	}
}

// Deletes expired messages with interval and saves cleaned history
func (h *History) Cleaner(
	ctx context.Context,
	path string,
	settings *conf.CleanerSettings,
) {
	// Get variables
	var (
		cleanupInterval = time.Duration(settings.CleanupInterval)
		messageTTL      = time.Duration(settings.MessageTTL)
	)

	// Start ticker
	t := time.NewTicker(cleanupInterval)
	defer t.Stop()

	// Clean and save on tick until context DONE
	defer log.Println("[history] cleaner shut down gracefully")
	for {
		select {
		case <-t.C:
			// Clean
			err := h.clean(ctx, messageTTL)
			if err != nil && errors.Is(err, context.Canceled) {
				return
			}
			// Save (skip extra context check)
			if err := h.Save(path); err != nil {
				log.Printf("%v: %v", errSaveFailed, err)
			}
		case <-ctx.Done():
			log.Println(ctxDoneMsg + opWaiting)
			return
		}
	}
}

// Deletes expired messages in history
func (h *History) clean(
	ctx context.Context,
	messageTTL time.Duration,
) error {
	var currentTime = time.Now()

	// CREATE error group & context
	// When ctx done, gctx done for all workers with logging once
	g, gctx := errgroup.WithContext(ctx)
	var logSendingOnce, logGettingOnce sync.Once

	// COLLECT jobs
	jobs := h.collectCleanJobs()
	if len(jobs) < 1 {
		return nil
	}

	// START job sender
	jobsChan := make(chan CleanJob, len(jobs))
	g.Go(func() error { // evaluates to error
		return jobSender(gctx, jobs, jobsChan, &logSendingOnce)
	})

	// START job receivers (clean workers)
	workerCount := min(runtime.GOMAXPROCS(0), len(jobs))
	for workerID := range workerCount {
		g.Go(func() error {
			return h.cleanWorker( // evaluates to error
				gctx, workerID, jobsChan, currentTime, messageTTL,
				&logGettingOnce,
			)
		})
	}

	return g.Wait() // evaluates to error
}

func (h *History) collectCleanJobs() []CleanJob {
	var jobs []CleanJob

	var (
		scqs = h.SharedChatQueues
		bots = h.Bots
	)

	// Add SHARED chat queues to jobs
	for _, scq := range scqs {
		jobs = append(jobs, CleanJob{
			ChatQueue: scq,
		})
	}

	// Add LOCAL chat queues & reply chains to jobs
	bots.mu.RLock()
	defer bots.mu.RUnlock()
	// Iterate over bot data
	for _, botData := range bots.History {
		sbh := botData.History // Omit contacts

		sbh.mu.RLock()
		// Iterate over chat histories
		for _, sch := range sbh.History {
			chatQueue, replyChains := sch.ChatQueue, sch.ReplyChains

			// Add local chat queue to jobs
			chatQueue.mu.RLock()
			if !chatQueue.IsShared {
				jobs = append(jobs, CleanJob{
					ChatQueue: chatQueue,
				})
			}
			chatQueue.mu.RUnlock()

			// Add reply chains to jobs
			replyChains.mu.RLock()
			jobs = append(jobs, CleanJob{
				ReplyChains: replyChains,
			})
			replyChains.mu.RUnlock()
		}
		sbh.mu.RUnlock()
	}

	log.Printf("[cleaner] collected %d jobs", len(jobs))
	return jobs
}

// Sends jobs to channel with group context
func jobSender(
	gctx context.Context,
	jobs []CleanJob,
	jobsChan chan<- CleanJob,
	logSendingOnce *sync.Once,
) error {
	// CLOSE channel after all sent
	defer close(jobsChan)

	// SEND jobs until group context DONE
	for _, job := range jobs {
		select {
		case jobsChan <- job:
		case <-gctx.Done(): // all workers done
			logSendingOnce.Do(func() { // log only first time
				log.Println(ctxDoneMsg + opSendingJobs)
			})
			return gctx.Err()
		}
	}

	return nil
}

// Gets clean jobs with group context and performs them
func (h *History) cleanWorker(
	gctx context.Context,
	workerID int,
	jobsChan <-chan CleanJob,
	currentTime time.Time,
	messageTTL time.Duration,
	logGettingOnce *sync.Once,
) error {
	// GET jobs until channel CLOSED or group context DONE
	for processed := 0; ; processed++ {
		select {
		case job, ok := <-jobsChan:
			if !ok {
				log.Println("[cleaner] jobs channel closed")
				log.Printf(
					"[cleaner] worker %d processed %d jobs",
					workerID, processed,
				)
				return nil
			}

			// Perform clean job
			job.perform(currentTime, messageTTL)

		case <-gctx.Done(): // all workers done
			logGettingOnce.Do(func() { // log only first time
				log.Println(ctxDoneMsg + opGettingJobs)
			})
			return gctx.Err()
		}
	}
}

// Deletes expired messages in chat queue
func (scq *SafeChatQueue) clean(
	currentTime time.Time,
	messageTTL time.Duration,
) {
	// Ensure secure access
	scq.mu.Lock()
	defer scq.mu.Unlock()

	// Get reply chains
	chatQueue := scq.ChatQueue

	// Create new slice pointing to the same array
	queue := chatQueue[:0]

	// Append every not-expired message entry to new slice
	for _, messageEntry := range chatQueue {
		if currentTime.Sub(messageEntry.Timestamp) <= messageTTL {
			queue = append(queue, messageEntry)
		}
	}

	// Set array to new slice
	scq.ChatQueue = queue
}

// Deletes expired messages in reply chains
func (src *SafeReplyChains) clean(
	currentTime time.Time,
	messageTTL time.Duration,
) {
	// Ensure secure access
	src.mu.Lock()
	defer src.mu.Unlock()

	// Get reply chains
	replyChains := src.ReplyChains

	// Delete messages which time of existence
	// is longer than time to live
	for line, messageEntry := range replyChains {
		if currentTime.Sub(messageEntry.Timestamp) > messageTTL {
			delete(replyChains, line)
		}
	}
}

=== File: ./tg-handler/history/saver.go ===
package history

import (
	"context"
	"errors"
	"log"
)

// Saver errors
var (
	ErrFinalSaveFailed = errors.New("[history] final save failed")
)

// Saves history on update signal
func (history *History) Saver(
	ctx context.Context, path string, updateCh <-chan any,
) {
	// Save history on signal until channel CLOSED or context DONE
	defer log.Println("[history] saver shut down gracefully")
	for {
		select {
		case _, ok := <-updateCh:
			if !ok { // Check if channel closed
				log.Println("[history] update channel was closed")
				return
			}
			history.Save(path)
		case <-ctx.Done():
			log.Println("[history] saver received shutdown signal")
			if err := history.Save(path); err != nil {
				log.Printf("%v: %v", ErrFinalSaveFailed, err)
			}
			return
		}
	}
}

=== File: ./tg-handler/history/chat_level.go ===
package history

import (
	"log"
	"sync"
)

const (
	chatQueueCap   = 256
	replyChainsCap = 256
)

// messaging.MessageInfo abstraction
type LineChain interface {
	lineProvider
	prevLineProvider
}

type lineProvider interface {
	Line() string
}

type prevLineProvider interface {
	PrevLine() string
}

// CHAT HISTORY

// Chat history consists from chat queue and reply chains.
// No pointer swap occures after initialization, no mutex needed.
type ChatHistory struct {
	ChatQueue   *SafeChatQueue   // Read-only
	ReplyChains *SafeReplyChains // Read-only
}

// Constructs chat history with
// shared queue for public chats, local queue for private chats.
func NewChatHistory(scq *SafeChatQueue) *ChatHistory {
	// If no safe queue, create it as local
	if scq == nil {
		scq = NewSafeChatQueue(false)
	}
	// Set queue as local or shared
	return &ChatHistory{
		ChatQueue:   scq,
		ReplyChains: NewSafeReplyChains(),
	}
}

// CHAT QUEUE BRANCH

type SafeChatQueue struct {
	mu        sync.RWMutex
	ChatQueue ChatQueue

	IsShared bool
}

// Constructs safe chat queue
// shared for public chats, local for private.
func NewSafeChatQueue(isShared bool) *SafeChatQueue {
	return &SafeChatQueue{
		ChatQueue: NewChatQueue(),
		IsShared:  isShared,
	}
}

type ChatQueue []MessageEntry

func NewChatQueue() ChatQueue {
	c := make(ChatQueue, 0, chatQueueCap)
	return c
}

// REPLY CHAINS BRANCH

type SafeReplyChains struct {
	mu          sync.RWMutex
	ReplyChains ReplyChains
}

func NewSafeReplyChains() *SafeReplyChains {
	return &SafeReplyChains{
		ReplyChains: NewReplyChains(),
	}

}

type ReplyChains map[string]MessageEntry

func NewReplyChains() ReplyChains {
	r := make(ReplyChains, replyChainsCap)
	return r
}

// METHODS

// Adds message to queue
func (ch *ChatHistory) AddToChatQueue(lc LineChain) {
	ch.ChatQueue.add(lc)
}

// Adds message to queue and chains
func (ch *ChatHistory) AddToBoth(lc LineChain) {
	ch.ChatQueue.add(lc)
	ch.ReplyChains.add(lc)
}

// Gets lines from safe chat queue with limit
func (scq *SafeChatQueue) GetLines(lim int) []string {
	// Ensure secure access
	scq.mu.RLock()
	defer scq.mu.RUnlock()

	// Call private getter securely
	return scq.ChatQueue.getLines(lim)
}

// Gets lines from reply chains with limit
func (src *SafeReplyChains) GetLines(
	prevLine string,
	lastLine string,
	lim int,
) []string {
	// Ensure secure access
	src.mu.RLock()
	defer src.mu.RUnlock()

	// Call private getter securely
	return src.ReplyChains.getLines(prevLine, lastLine, lim)
}

// Adds message line to chat queue
func (scq *SafeChatQueue) add(lc LineChain) {
	// Ensure secure access
	scq.mu.Lock()
	defer scq.mu.Unlock()

	// For shared chat queue check if line has been added
	var (
		isShared = scq.IsShared
		cq       = &scq.ChatQueue
	)
	if isShared && len(*cq) > 0 {
		lastMsg := (*cq)[len(*cq)-1]
		if lastMsg.Line == lc.Line() {
			return
		}
	}

	cq.appendLine(lc.Line())
	log.Println("[history] chat queue++")
}

// Adds message line to reply chains atomically
func (src *SafeReplyChains) add(lc LineChain) {
	// Ensure secure access
	src.mu.Lock()
	defer src.mu.Unlock()

	// Get reply chains
	rc := src.ReplyChains

	// Get chain and set it
	lines := rc.getLines(lc.PrevLine(), lc.Line(), 2)
	if ok := rc.setLines(lines); ok {
		log.Println("[history] reply chains++")
	}
}

// Appends message line to chat queue
func (cq *ChatQueue) appendLine(line string) {
	*cq = append(*cq, *NewMessageEntry(line))
}

// Gets lines from chat queue with limit
func (cq ChatQueue) getLines(lim int) []string {
	lines := make([]string, 0, lim)

	// Shift by limit if exceeded
	shift := min(len(cq), lim)
	// Get start index by shifting
	start := len(cq) - shift

	// Accumulate lines
	for _, msg := range cq[start:] {
		lines = append(lines, msg.Line)
	}

	log.Printf("[history] chat queue: %d lines", len(lines))
	return lines
}

// Gets lines from reply chains with limit
func (rc ReplyChains) getLines(
	prevLine string,
	lastLine string,
	lim int,
) []string {
	// Incomplete chain, no unroll
	if prevLine == "" {
		return []string{lastLine}
	}
	// Complete chain, proceed to unroll
	replyChain := []string{lastLine, prevLine}

	// Accumulate lines unrolling reply chain backwards up to limit
	for range lim - 2 {
		lastLine = prevLine
		if msg, ok := rc[lastLine]; ok {
			prevLine = msg.Line
			replyChain = append(replyChain, prevLine)
		} else {
			break
		}
	}

	// Reverse reply chain
	for i, j := 0, len(replyChain)-1; i < j; i, j = i+1, j-1 {
		replyChain[i], replyChain[j] = replyChain[j], replyChain[i]
	}

	log.Printf("[history] reply chain: %d lines", len(replyChain))
	return replyChain
}

// Sets message lines in safe reply chains
func (rc ReplyChains) setLines(lines []string) bool {
	// Incomplete or too long chain, no set
	if len(lines) != 2 {
		return false
	}

	// Set lines
	var (
		prevLine = lines[0]
		lastLine = lines[1]
	)

	// Set chain
	rc[lastLine] = *NewMessageEntry(prevLine)

	return true
}

=== File: ./tg-handler/history/message_level.go ===
package history

import (
	"time"
)

type MessageEntry struct {
	Line      string    `json:"msg"`
	Timestamp time.Time `json:"ts"`
}

func NewMessageEntry(line string) *MessageEntry {
	return &MessageEntry{
		Line:      line,
		Timestamp: time.Now(),
	}
}

=== File: ./tg-handler/history/bot_level.go ===
package history

import (
	"fmt"
	"strings"
	"sync"

	"tg-handler/carma"
	"tg-handler/tags"
)

// Constants
const (
	botHistoryCap  = 256
	botContactsCap = 256
)

// BOT DATA

// Bot data consists from bot history, chat agnostic bot contacts.
// No pointer swap occures after initialization, no mutex needed.
type BotData struct {
	History  *SafeBotHistory  // Read-only
	Contacts *SafeBotContacts // Read-only
}

func NewBotData() *BotData {
	return &BotData{
		History:  NewSafeBotHistory(),
		Contacts: NewSafeBotContacts(),
	}
}

// BOT HISTORY BRANCH

type SafeBotHistory struct {
	mu      sync.RWMutex
	History BotHistory
}

func NewSafeBotHistory() *SafeBotHistory {
	return &SafeBotHistory{
		History: NewBotHistory(),
	}
}

type BotHistory map[int64]*ChatHistory

func NewBotHistory() BotHistory {
	h := make(BotHistory, botHistoryCap)
	return h
}

// BOT CONTACTS BRANCH

type SafeBotContacts struct {
	mu       sync.RWMutex
	Contacts BotContacts
}

func NewSafeBotContacts() *SafeBotContacts {
	return &SafeBotContacts{
		Contacts: NewBotContacts(),
	}
}

func (sbcs *SafeBotContacts) String() string {
	// Ensure secure access
	sbcs.mu.RLock()
	defer sbcs.mu.RUnlock()

	// Return string
	return sbcs.Contacts.String()
}

type BotContacts map[string]BotContact

func NewBotContacts() BotContacts {
	bc := make(BotContacts, botContactsCap)
	return bc
}

func (bcs BotContacts) String() string {
	var sb strings.Builder

	// Describe contacts
	sb.WriteString("Contacts (users known to you):\n")

	// Present contacts
	if bcs == nil {
		sb.WriteString("<no contacts>")
		return sb.String()
	}
	for userName, contact := range bcs {
		sb.WriteString(
			fmt.Sprintf("user: %s\n%s\n", userName, contact),
		)
	}

	return sb.String()
}

// BOT CONTACT

type BotContact struct {
	Carma carma.Carma
	Tags  tags.Tags
}

func (bc BotContact) String() string {
	return fmt.Sprintf("carma: %d\ntags: %s\n", bc.Carma, bc.Tags)
}

// METHODS

// BOT HISTORY BRANCH

// Gets safe chat history and status
func (sbh *SafeBotHistory) Get(
	cid int64,
	scq *SafeChatQueue, // Preinit for public, nil for private chats
) (*ChatHistory, bool) {
	// Happy path: return existing chat history
	if chatHistory, ok := sbh.get(cid); ok {
		return chatHistory, true
	}

	// Unhappy path: return new chat history
	return sbh.init(cid, scq), false

}

func (sbh *SafeBotHistory) get(cid int64) (*ChatHistory, bool) {
	// Ensure secure access
	sbh.mu.RLock()
	defer sbh.mu.RUnlock()

	chatHistory, ok := sbh.History[cid]
	return chatHistory, ok
}

func (sbh *SafeBotHistory) init(
	cid int64,
	scq *SafeChatQueue, // Preinit for public, nil for private chats
) *ChatHistory {
	// Ensure secure access
	sbh.mu.Lock()
	defer sbh.mu.Unlock()

	// Double check if init after lock release
	if chatHistory, ok := sbh.History[cid]; ok {
		return chatHistory
	}

	// Return new chat history
	chatHistory := NewChatHistory(scq)
	sbh.History[cid] = chatHistory
	return chatHistory
}

// BOT CONTACTS BRANCH

// Gets bot contact
func (sbcs *SafeBotContacts) Get(userName string) BotContact {
	// Ensure secure access
	sbcs.mu.RLock()
	defer sbcs.mu.RUnlock()

	// Return existing bot contact
	if botContact, ok := sbcs.Contacts[userName]; ok {
		return botContact
	}

	// Return new bot contact
	return BotContact{}
}

// Sets bot contact
func (sbcs *SafeBotContacts) Set(
	userName string,
	botContact BotContact,
) {
	// Ensure secure access
	sbcs.mu.Lock()
	defer sbcs.mu.Unlock()

	// Set bot contact
	sbcs.Contacts[userName] = botContact
}

=== File: ./tg-handler/history/proto_adapter.go ===
package history

import (
	"time"

	"tg-handler/carma"
	"tg-handler/history/pb"
	"tg-handler/tags"
)

// --- ADAPTERS ---

// Convert Go internal -> Proto
func (h *History) toProto() *pb.RootHistory {
	root := &pb.RootHistory{
		SharedQueues: make(map[int64]*pb.ChatQueue),
		Bots:         make(map[string]*pb.BotData),
	}

	// Snapshot Shared Queues
	for cid, scq := range h.SharedChatQueues {
		root.SharedQueues[cid] = chatQueueToProto(scq.ChatQueue)
	}

	// Snapshot Bots
	for name, botData := range h.Bots.History {
		pbBot := &pb.BotData{
			Chats:    make(map[int64]*pb.ChatHistory),
			Contacts: make(map[string]*pb.BotContact),
		}

		// Contacts
		for user, c := range botData.Contacts.Contacts {
			pbBot.Contacts[user] = &pb.BotContact{
				Carma: int32(c.Carma),
				Tags:  c.Tags.Serialize(),
			}
		}

		// Chat Histories
		for cid, ch := range botData.History.History {
			pbChat := &pb.ChatHistory{
				ReplyChains: replyChainsToProto(ch.ReplyChains.ReplyChains),
			}

			// KEY LOGIC: If shared, do not save local_queue
			if !ch.ChatQueue.IsShared {
				pbChat.LocalQueue = chatQueueToProto(ch.ChatQueue.ChatQueue)
			}

			pbBot.Chats[cid] = pbChat
		}
		root.Bots[name] = pbBot
	}

	return root
}

// Convert Proto -> Go internal
func fromProto(p *pb.RootHistory, cids []int64) *History {
	h := NewHistory(cids) // Helper to init empty maps

	// Load Shared Queues
	// Overwrite empty ones created by NewHistory or fill new
	for cid, pQueue := range p.SharedQueues {
		// Check if this CID is allowed
		if _, isAllowed := h.SharedChatQueues[cid]; !isAllowed {
			// Skip loading history for chats removed from config
			continue
		}

		scq := NewSafeChatQueue(true)
		scq.ChatQueue = protoToChatQueue(pQueue)
		h.SharedChatQueues[cid] = scq
	}

	// Load Bots
	for name, pBot := range p.Bots {
		botData := NewBotData()

		// Contacts
		for user, pCont := range pBot.Contacts {
			botData.Contacts.Contacts[user] = BotContact{
				Carma: carma.Carma(pCont.Carma),
				Tags:  tags.DeserializeTags(pCont.Tags),
			}
		}

		// Histories
		for cid, pChat := range pBot.Chats {
			// Restore Reply Chains
			replyChains := NewSafeReplyChains()
			replyChains.ReplyChains = protoToReplyChains(pChat.ReplyChains)

			// Restore Chat Queue
			var scq *SafeChatQueue

			if pChat.LocalQueue != nil {
				// Case A: It was saved as local
				scq = NewSafeChatQueue(false)
				scq.ChatQueue = protoToChatQueue(pChat.LocalQueue)
			} else {
				// Case B: It is shared, link to the SharedChatQueues
				if shared, exists := h.SharedChatQueues[cid]; exists {
					scq = shared
				} else {
					// Fallback if shared queue missing (shouldn't happen)
					scq = NewSafeChatQueue(true)
				}
			}

			botData.History.History[cid] = &ChatHistory{
				ChatQueue:   scq,
				ReplyChains: replyChains,
			}
		}
		h.Bots.History[name] = botData
	}

	return h
}

// --- HELPERS ---

func chatQueueToProto(cq ChatQueue) *pb.ChatQueue {
	pq := &pb.ChatQueue{Messages: make([]*pb.MessageEntry, len(cq))}
	for i, m := range cq {
		pq.Messages[i] = &pb.MessageEntry{
			Line:      m.Line,
			Timestamp: m.Timestamp.Unix(),
		}
	}
	return pq
}

func protoToChatQueue(pq *pb.ChatQueue) ChatQueue {
	if pq == nil {
		return make(ChatQueue, 0)
	}
	cq := make(ChatQueue, len(pq.Messages))
	for i, m := range pq.Messages {
		cq[i] = MessageEntry{
			Line:      m.Line,
			Timestamp: time.Unix(m.Timestamp, 0),
		}
	}
	return cq
}

func replyChainsToProto(rc ReplyChains) *pb.ReplyChains {
	prc := &pb.ReplyChains{Chains: make(map[string]*pb.MessageEntry)}
	for k, v := range rc {
		prc.Chains[k] = &pb.MessageEntry{
			Line:      v.Line,
			Timestamp: v.Timestamp.Unix(),
		}
	}
	return prc
}

func protoToReplyChains(prc *pb.ReplyChains) ReplyChains {
	rc := make(ReplyChains)
	if prc == nil {
		return rc
	}
	for k, v := range prc.Chains {
		rc[k] = MessageEntry{
			Line:      v.Line,
			Timestamp: time.Unix(v.Timestamp, 0),
		}
	}
	return rc
}

=== File: ./tg-handler/history/history.proto ===
syntax = "proto3";

package history;
option go_package = "tg-handler/history/pb"; // Full path + package


message MessageEntry {
    string line = 1;
    int64 timestamp = 2; // Unix timestamp < line
}

message ChatQueue {
    repeated MessageEntry messages = 1;
}

message ReplyChains {
    map<string, MessageEntry> chains = 1;
}

message BotContact {
    int32 carma = 1;
    string tags = 2;
}

message ChatHistory { // Only local queues stored here
    ReplyChains reply_chains = 1;
    ChatQueue local_queue = 2;
}

message BotData { // Contacts stored here as chat-agnostic
    map<int64, ChatHistory> chats = 1;
    map<string, BotContact> contacts = 2;
}

message RootHistory { // Shared queues stored here as bot-agnotic
    map<int64, ChatQueue> shared_queues = 1;
    map<string, BotData> bots = 2;
}

=== File: ./tg-handler/history/history_level.go ===
package history

import (
	"errors"
	"fmt"
	"log"
	"os"
	"sync"

	"google.golang.org/protobuf/proto"

	"tg-handler/history/pb"
)

// History consists from bot histories, bot-agnostic shared queues.
// No pointer swap occures after initialization, no mutex needed.
type History struct {
	Bots             *SafeBotsHistory // Read-only (secured inside)
	SharedChatQueues SharedChatQueues // Read-only
}

func NewHistory(cids []int64) *History {
	return &History{
		Bots:             NewSafeBotsHistory(),
		SharedChatQueues: NewSharedChatQueues(cids),
	}
}

// Safe bot history consists from history read/written concurrently
// by bots, cleaner, so mutex needed.
type SafeBotsHistory struct {
	mu      sync.RWMutex
	History BotsHistory
}

func NewSafeBotsHistory() *SafeBotsHistory {
	return &SafeBotsHistory{
		History: make(BotsHistory),
	}
}

// Bot data storage
type BotsHistory map[string]*BotData

// Shared chat queues for all allowed public chats,
// implicitly used to set chat queue on chat level if public
// to avoid memory duplication and preserve simplicity for bots.
type SharedChatQueues map[int64]*SafeChatQueue

func NewSharedChatQueues(cids []int64) SharedChatQueues {
	cq := make(SharedChatQueues, len(cids))
	for _, cid := range cids {
		cq[cid] = NewSafeChatQueue(true)
	}
	return cq
}

// History errors
var (
	ErrGetPathFailed = errors.New(
		"[history] failed to get history path",
	)
	ErrReadFailed = errors.New(
		"[history] failed to read history file",
	)
	ErrWriteFailed = errors.New(
		"[history] failed to write history file",
	)
	ErrMarshalFailed = errors.New(
		"[history] failed to marshal history file",
	)
	ErrUnmarshalFailed = errors.New(
		"[history] failed to unmarshal history file",
	)
)

// UNSAFE! Loads history or panics
func MustLoadHistory(source string, cids []int64) *History {
	// Check if source is empty
	if source == "" {
		log.Panicf("%v", ErrGetPathFailed)
	}

	// Try to read file
	data, err := os.ReadFile(source)
	if os.IsNotExist(err) {
		// Return new if file doesn't exist
		return NewHistory(cids)
	} else if err != nil {
		log.Panicf("%v: %v", ErrReadFailed, err)
	}

	// Unmarshal
	var protoRoot pb.RootHistory
	if err := proto.Unmarshal(data, &protoRoot); err != nil {
		log.Printf("%v: %v", ErrUnmarshalFailed, err)
		log.Printf("[memory] opting to empty history")
		return NewHistory(cids)
	}

	// Convert back to internal structure
	history := fromProto(&protoRoot, cids)

	log.Println("[memory] history loaded")
	return history
}

// Saves history
func (h *History) Save(dest string) error {
	h.lock()
	defer h.unlock()

	// Convert to Proto struct
	protoRoot := h.toProto()

	// Marshal to binary
	data, err := proto.Marshal(protoRoot)
	if err != nil {
		return fmt.Errorf("%w: %v", ErrMarshalFailed, err)
	}

	// Write file
	if err := os.WriteFile(dest, data, 0644); err != nil {
		return fmt.Errorf("%w: %v", ErrWriteFailed, err)
	}

	log.Println("[memory] history written")
	return nil
}

// Gets bot data
func (sbh *SafeBotsHistory) Get(botName string) *BotData {
	// Happy path: Return existing bot data
	if botData, ok := sbh.get(botName); ok {
		return botData
	}

	// Unhappy path: Return new bot data
	return sbh.init(botName)
}

// Return existing bot data with status
func (sbh *SafeBotsHistory) get(botName string) (*BotData, bool) {
	// Ensure secure access
	sbh.mu.RLock()
	defer sbh.mu.RUnlock()

	botData, ok := sbh.History[botName]
	return botData, ok
}

// Create new bot data
func (sbh *SafeBotsHistory) init(botName string) *BotData {
	// Ensure secure access
	sbh.mu.Lock()
	defer sbh.mu.Unlock()

	// Double check if init after lock release
	if botData, ok := sbh.History[botName]; ok {
		return botData
	}

	// Return new bot data
	botData := NewBotData()
	sbh.History[botName] = botData
	return botData
}

// Locks history in cascade
func (h *History) lock() {
	var (
		scqs = h.SharedChatQueues
		bots = h.Bots
	)

	// Firstly lock SHARED chat queues
	for _, scq := range scqs {
		scq.mu.Lock()
	}

	// Secondly lock LOCAL chat queues and reply chains
	bots.mu.Lock()
	for _, botData := range bots.History {
		var (
			history  = botData.History
			contacts = botData.Contacts
		)
		history.mu.Lock()
		contacts.mu.Lock()

		for _, sch := range history.History {
			var (
				chatQueue   = sch.ChatQueue
				replyChains = sch.ReplyChains
			)

			// Lock chat queue if local
			if !chatQueue.IsShared {
				chatQueue.mu.Lock()
			}

			// Lock reply chains (always local)
			replyChains.mu.Lock()
		}
	}
}

// Unlocks history in cascade
func (h *History) unlock() {
	var (
		scqs = h.SharedChatQueues
		bots = h.Bots
	)

	// Firstly lock SHARED chat queues
	for _, scq := range scqs {
		scq.mu.Unlock()
	}

	// Secondly lock LOCAL chat queues and reply chains
	bots.mu.Unlock()
	for _, botData := range bots.History {
		var (
			history  = botData.History
			contacts = botData.Contacts
		)
		history.mu.Unlock()
		contacts.mu.Unlock()

		for _, sch := range history.History {
			var (
				chatQueue   = sch.ChatQueue
				replyChains = sch.ReplyChains
			)

			// Lock chat queue if local
			if !chatQueue.IsShared {
				chatQueue.mu.Unlock()
			}

			// Lock reply chains (always local)
			replyChains.mu.Unlock()
		}
	}
}

=== File: ./tg-handler/go.mod ===
module tg-handler

go 1.25.5

require (
	github.com/go-telegram-bot-api/telegram-bot-api/v5 v5.5.1
	golang.org/x/sync v0.19.0
	golang.org/x/text v0.32.0
	google.golang.org/protobuf v1.36.11
)

=== File: ./tg-handler/Dockerfile ===
# Stage 1: BUILDER
FROM golang:1.25.6-alpine3.23 AS builder

LABEL stage=gobuilder

WORKDIR /build

ENV CGO_ENABLED=0
ENV GOOS=linux
ENV GOARCH=amd64

# Dependencies
RUN apk update && apk add --no-cache protoc git
RUN go install google.golang.org/protobuf/cmd/protoc-gen-go@latest

# Modules
COPY ./tg-handler/go.mod ./tg-handler/go.sum .
RUN go mod download

# Source code copy
COPY ./tg-handler .

# Code generation
RUN mkdir -p history/pb
RUN protoc --go_out=. --go_opt=module=tg-handler history/history.proto

# Build
RUN go build -ldflags="-s -w" main.go

# Compression (optional)
# RUN apk add --no-cache upx && upx --best --lzma main

# Stage 2: IMAGE
FROM alpine

# Dependencies
RUN apk update --no-cache && apk add --no-cache ca-certificates

WORKDIR /app

# Copy the binary from builder stage
COPY --from=builder /build/main .

ENTRYPOINT ["./main"]

=== File: ./tg-handler/main.go ===
package main

import (
	"context"
	"log"
	"os"
	"os/signal"
	"sync"
	"syscall"

	"tg-handler/bot"
	"tg-handler/conf"
	"tg-handler/history"
	"tg-handler/secret"
)

const InitConfPath = "./confs/init.json"

func main() {
	// Load API keys from secret file or panic
	apiKeys := secret.MustLoadAPIKeys()

	// Terminate on termination signal
	ctx, cancel := signal.NotifyContext(
		context.Background(), os.Interrupt, syscall.SIGTERM,
	)
	defer cancel()

	// Get init config
	iConf := conf.MustLoadInitConf(InitConfPath)

	// Get safe history
	h := history.MustLoadHistory(
		iConf.Paths.History,
		// Preinitialize SafeChatQueues with allowed chat IDs
		iConf.BotSettings.AllowedChats.IDs,
	)

	// Start cleaner and bots
	wg, updateCh := startBots(ctx, iConf, apiKeys, h)

	// Await termination signal
	<-ctx.Done()
	log.Println("[main] shutting down...")

	// Await bots shutdown
	log.Println("[main] awaiting services to shutdown...")
	wg.Wait()
	close(updateCh)
	log.Println("[main] all services shutdown gracefully")
}

// Starts bots with API keys
func startBots(
	ctx context.Context,
	iConf *conf.InitConf,
	apiKeys []string,
	h *history.History,
) (*sync.WaitGroup, chan any) {
	var (
		wg       sync.WaitGroup
		updateCh = make(chan any)

		historyPath = iConf.Paths.History
	)

	// Start cleaner
	wg.Add(1)
	go func() {
		defer wg.Done()
		h.Cleaner(ctx, historyPath, &iConf.CleanerSettings)
	}()

	// Start all bots
	for _, apiKey := range apiKeys {
		wg.Add(1)
		go func() {
			defer wg.Done()
			bot := bot.New(apiKey, iConf, h, updateCh)
			bot.Start(ctx)
		}()
	}

	// Start history saver
	wg.Add(1)
	go func() {
		defer wg.Done()
		h.Saver(ctx, historyPath, updateCh)
	}()

	return &wg, updateCh
}

=== File: ./tg-handler/messaging/reply.go ===
package messaging

import (
	"errors"
	"fmt"
	"log"

	tg "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// Messaging errors
var (
	ErrDirectReplyFailed   = errors.New("[messaging] direct reply failed")
	ErrIndirectReplyFailed = errors.New("[messaging] indirect reply failed")
)

// Template for formatting replied line and reply text on second try
const ReplyDeletedT = "> '%s'\n\n%s"

// Try to reply twice: with reply, with separate message
func Reply(bot *tg.BotAPI, c *ChatInfo, text string) *tg.Message {
	var (
		mid = c.LastMsg.ID
		cid = c.ID
	)

	// Get and set message config
	m := tg.NewMessage(cid, text)
	m.ReplyToMessageID = mid

	// Try to reply with reply
	response, err := bot.Send(m)
	if err != nil { // Try to reply with separate message
		log.Printf("%v: %v", ErrDirectReplyFailed, err)
		m.ReplyToMessageID = 0
		m.Text = fmt.Sprintf(ReplyDeletedT, c.LastMsg.Line(), text)
		response, err = bot.Send(m)
	}
	if err != nil {
		log.Printf("%v: %v", ErrIndirectReplyFailed, err)
	}

	return &response
}

=== File: ./tg-handler/messaging/chat_info.go ===
package messaging

import (
	"fmt"

	tg "github.com/go-telegram-bot-api/telegram-bot-api/v5"

	"tg-handler/history"
)

type ChatInfo struct {
	ID        int64
	Title     string
	History   *history.ChatHistory
	IsAllowed bool
	IsPrivate bool
	LastMsg   *MessageInfo
}

// Constructs chat info by following bot procedure
// on how to validate chat ID. Reuses chat queues
// for public chats.
func NewChatInfo(
	m *MessageInfo,
	sbh *history.SafeBotHistory,
	shared history.SharedChatQueues,
	validateChatID func(int64) bool,
) *ChatInfo {
	// Get message vars
	var (
		chat        = m.Chat
		sender      = m.Sender()
		isFromAdmin = m.IsFromAdmin
	)

	// Get chat vars
	var (
		cid       = chat.ID
		isPrivate = chat.IsPrivate()
	)

	// Process message based on sender
	var isAllowed bool
	var safeChatQueue *history.SafeChatQueue
	if isFromAdmin { // Message from admin: allowed, new chat queue
		isAllowed = true
	} else { // Ordinary message: validated, shared chat queue
		isAllowed = validateChatID(cid)
		safeChatQueue = shared[cid]
	}

	// Get history by passing nil/shared safe chat queue
	// for admin chats and public chats respectively,
	// nil means new safe chat queue will be created
	SafeChatHistory, _ := sbh.Get(cid, safeChatQueue)

	return &ChatInfo{
		ID:        cid,
		Title:     getChatTitle(chat, sender, isPrivate),
		History:   SafeChatHistory,
		IsAllowed: isAllowed,
		LastMsg:   m,
	}
}

// Gets chat title for any chat
func getChatTitle(
	chat *tg.Chat,
	sender string,
	isPrivate bool,
) string {
	if isPrivate {
		return fmt.Sprintf("%s's private", sender)
	}
	return chat.Title
}

=== File: ./tg-handler/messaging/message_info.go ===
package messaging

import (
	"golang.org/x/text/cases"
	"golang.org/x/text/language"

	tg "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// Recursive type.
// Provides Line(), PrevLine() methods to construct reply chain.
// Provides ID() and Sender() as methods.
type MessageInfo struct {
	ID           int    // Message identifier
	sender       string // UserName | FirstName (+LastName)
	line         string // "Sender: text"
	IsTriggering bool   // Is message meant to be replied
	IsFromAdmin  bool   // Is message meant to be queued privately
	Chat         *tg.Chat
	prevMsg      *MessageInfo // Previous message info
}

// Constructs message info by following bot procedures
// on how to detect admin/reply/mentions; modify mentions.
func NewMessageInfo(
	bot *tg.BotAPI,
	msg *tg.Message,
	detectAdmin func(*tg.Message, string) bool,
	detectReply func(*tg.Message) bool,
	detectMentions func(string) bool,
	modifyMentions func(string) string,
	level int,
) *MessageInfo {
	// Handle nil and too deep recursion
	if msg == nil || level > 2 {
		return nil
	}

	// Get sender and text
	var (
		sender = getSender(msg)
		text   = getText(msg)
	)
	// Return nil if no sender or text
	if sender == "" || text == "" {
		return nil
	}

	// Get basic info
	var (
		isFromAdmin = detectAdmin(msg, sender)
		isReplied   = detectReply(msg)
		isMentioned = detectMentions(text)
	)

	// Modify bot mentions if they exist
	if isMentioned {
		text = modifyMentions(text)
	}

	return &MessageInfo{
		Chat:         msg.Chat,
		ID:           msg.MessageID,
		sender:       sender,
		line:         getLine(sender, text),
		IsTriggering: isFromAdmin || isReplied || isMentioned,
		IsFromAdmin:  isFromAdmin,
		prevMsg: NewMessageInfo(
			bot, msg.ReplyToMessage,
			detectAdmin,
			detectReply,
			detectMentions,
			modifyMentions,
			level+1,
		),
	}
}

// Line exposed
func (m *MessageInfo) Line() string {
	return m.line
}

// Previous line exposed
func (m *MessageInfo) PrevLine() string {
	prevMsg := m.prevMsg
	if prevMsg != nil {
		return prevMsg.Line()
	}
	return ""
}

// Sender exposed
func (m *MessageInfo) Sender() string {
	return m.sender
}

// Gets UserName | FirstName (+LastName)
func getSender(msg *tg.Message) string {
	return msg.From.String()
}

// Gets Text | Caption
func getText(msg *tg.Message) (text string) {
	if msg.Text != "" {
		text = msg.Text
	}
	if msg.Caption != "" {
		text = msg.Caption
	}
	return text
}

// Gets "Sender: text" message history representation
func getLine(sender string, text string) string {
	titleizer := cases.Title(language.English)
	return titleizer.String(sender) + ": " + text
}

=== File: ./tg-handler/messaging/typing.go ===
package messaging

import (
	"context"
	"errors"
	"log"
	"time"

	tg "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// Typing errors
var (
	ErrSignalFailed = errors.New("[messaging] signal request failed")
)

// Sends typing signal until context done
func Type(ctx context.Context, bot *tg.BotAPI, c *ChatInfo) {
	const (
		signal   = "typing"
		interval = 3 * time.Second
	)

	cid := c.ID

	// Type right away
	sendSignal(bot, cid, signal)

	// Set ticker with interval
	t := time.NewTicker(interval)
	defer t.Stop()

	// Type on ticks until context DONE
	for {
		select {
		case <-t.C:
			sendSignal(bot, cid, signal)
		case <-ctx.Done():
			log.Println("[messaging] typing context done")
			return
		}
	}
}

// Sends signal via bot in specific chat
func sendSignal(bot *tg.BotAPI, cid int64, signal string) {
	actConf := tg.NewChatAction(cid, signal)
	_, err := bot.Request(actConf)
	if err != nil {
		log.Printf("%v for <%s>: %v", ErrSignalFailed, signal, err)
	}
}

=== File: ./tg-handler/selectIdx/selectIdx.go ===
package selectIdx

import (
	"errors"
	"fmt"
	"strconv"
)

// Selection errors
var (
	ErrSelectNumNaN = errors.New(
		"select number is not a number",
	)
	ErrSelectIdxOOB = errors.New(
		"select index is out of bounds",
	)
)

type SelectIdx int

func New(s string, lim int) (SelectIdx, error) {
	// Convert number
	num, err := strconv.Atoi(s)
	if err != nil {
		return 0, ErrSelectNumNaN
	}

	// Calculate index
	idx := num - 1

	// Check index bounds
	if idx < 0 || idx >= lim {
		return 0, ErrSelectIdxOOB
	}

	return SelectIdx(idx), nil
}

// Select index in human-readable format
func (si SelectIdx) String() string {
	return fmt.Sprintf("selection index %d", si)
}

=== File: ./tg-handler/conf/init.go ===
package conf

import (
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"os"
	"strings"
	"time"
)

// Placeholder numbers for templates
const (
	responseSNum = 4
	responseDNum = 0

	selectSNum = 3
	selectDNum = 1

	tagsSNum = 7
	tagsDNum = 1

	carmaSNum = 6
	carmaDNum = 0
)

// Initialization config errors
var (
	errIReadFailed          = errors.New("[conf] read init config failed")
	errIUnmarshalFailed     = errors.New("[conf] unmarshal init config failed")
	errIEmptyTemplate       = errors.New("[conf] empty template")
	errIWrongPlaceholderNum = errors.New("[conf] wrong placeholder number")
)

// Initialization config
type InitConf struct {
	Paths           Paths           `json:"paths"`
	CleanerSettings CleanerSettings `json:"cleaner_settings"`
	BotSettings     BotSettings     `json:"bot_settings"`
}

// Paths
type Paths struct {
	History     string `json:"history"`
	BotsConfDir string `json:"bots_conf_dir"`
}

// Cleaner settings
type CleanerSettings struct {
	MessageTTL      Duration `json:"msg_ttl"`
	CleanupInterval Duration `json:"cleanup_interval"`
}

// Bot settings
type BotSettings struct {
	PromptTemplates PromptTemplates `json:"prompt_templates"`
	AllowedChats    AllowedChats    `json:"allowed_chats"`
	MemoryLimits    MemoryLimits    `json:"memory_limits"`
}

// Allowed chats
type AllowedChats struct {
	Usernames []string `json:"usernames"`
	IDs       []int64  `json:"ids"`
}

// Prompt templates
type PromptTemplates struct {
	Response string `json:"response"`
	Select   string `json:"select"`
	Tags     string `json:"tags"`
	Carma    string `json:"carma"`
}

// Memory limits
type MemoryLimits struct {
	ChatQueue  int `json:"chat_queue"`
	ReplyChain int `json:"reply_chain"`
	Tags       int `json:"tags"`
}

type Duration time.Duration

func (d *Duration) UnmarshalJSON(b []byte) error {
	var s string
	if err := json.Unmarshal(b, &s); err != nil {
		return err
	}
	dur, err := time.ParseDuration(s)
	if err != nil {
		return err
	}
	*d = Duration(dur)
	return nil
}

// Loads init config or panics
func MustLoadInitConf(confPath string) *InitConf {
	var initConf InitConf

	// Read JSON data from file
	data, err := os.ReadFile(confPath)
	if err != nil {
		log.Panicf(
			"%v (%s): %v", errIReadFailed, confPath, err,
		)
	}

	// Decode JSON data to InitConf
	err = json.Unmarshal(data, &initConf)
	if err != nil {
		log.Panicf(
			"%v (%s): %v", errIUnmarshalFailed, confPath, err,
		)
	}

	// Validate prompt templates or panic
	mustValidateTemplates(&initConf.BotSettings.PromptTemplates)

	return &initConf
}

// Validates prompt templates
func mustValidateTemplates(templates *PromptTemplates) {
	mustValidateResponseTemplate(templates.Response)
	mustValidateSelectTemplate(templates.Select)
	mustValidateTagsTemplate(templates.Tags)
	mustValidateCarmaTemplate(templates.Carma)
}

// Validates response template or panics
func mustValidateResponseTemplate(template string) {
	const tType = "response"
	mustValidateNumOf(template, "%s", responseSNum, tType)
	mustValidateNumOf(template, "%d", responseDNum, tType)
}

// Validates select template or panics
func mustValidateSelectTemplate(template string) {
	const tType = "select"
	mustValidateNumOf(template, "%s", selectSNum, tType)
	mustValidateNumOf(template, "%d", selectDNum, tType)
}

// Validates note template or panics
func mustValidateTagsTemplate(template string) {
	const tType = "tags"
	mustValidateNumOf(template, "%s", tagsSNum, tType)
	mustValidateNumOf(template, "%d", tagsDNum, tType)
}

// Validates all templates or panics
func mustValidateCarmaTemplate(template string) {
	const tType = "carma"
	mustValidateNumOf(template, "%s", carmaSNum, tType)
	mustValidateNumOf(template, "%d", carmaDNum, tType)
}

// Validates number of template placeholders or panic
func mustValidateNumOf(
	template string, placeholder string, n int, tType string,
) {
	// Handle empty template
	if template == "" {
		log.Panicf("%v", errIEmptyTemplate)
	}

	// Set placeholder error
	var err error = fmt.Errorf(
		"%w in %s template", errIWrongPlaceholderNum, tType,
	)

	// Check placeholder number or panic
	num := strings.Count(template, placeholder)
	if num < n {
		log.Fatalf("%v: less than %d %s", err, n, placeholder)
	}
	if num > n {
		log.Fatalf("%v: more than %d %s", err, n, placeholder)
	}
}

=== File: ./tg-handler/conf/bot.go ===
package conf

import (
	"encoding/json"
	"errors"
	"log"
	"os"
)

// Bot config errors
var (
	errBReadFailed           = errors.New("[conf] read bot config failed")
	errBUnmarshalFailed      = errors.New("[conf] unmarshal bot config failed")
	errBNegativeCandidateNum = errors.New("[conf] negative candidate number")
)

// Bot config
type BotConf struct {
	Main     MainSettings     `json:"bot_conf"`
	Optional OptionalSettings `json:"options"`
}

// Main settings for LLM
type MainSettings struct {
	Role         string `json:"role"`
	CandidateNum int    `json:"candidate_num"`
}

// Optional settings for LLM
type OptionalSettings struct {
	Temperature   float32 `json:"temperature,omitempty"`
	RepeatPenalty float32 `json:"repeat_penalty,omitempty"`
	TopP          float32 `json:"top_p,omitempty"`
	TopK          int     `json:"top_k,omitempty"`
	NumPredict    int     `json:"num_predict,omitempty"`
	Seed          int     `json:"seed,omitempty"`
}

// Loads settings or panics
func MustLoadBotConf(confPath string) *BotConf {
	var botConf BotConf

	// Read JSON data from file
	data, err := os.ReadFile(confPath)
	if err != nil {
		log.Fatalf("%v: %v", errBReadFailed, err)
	}

	// Decode JSON data to settings
	err = json.Unmarshal(data, &botConf)
	if err != nil {
		log.Fatalf("%v: %v", errBUnmarshalFailed, err)
	}

	// Validate candidate number or panic
	mustValidateCandidateNum(&botConf)

	return &botConf
}

// Validates candidate num or panics
func mustValidateCandidateNum(conf *BotConf) {
	if conf.Main.CandidateNum < 0 {
		log.Fatal(errBNegativeCandidateNum)
	}
}

=== File: ./tg-handler/model/candidates.go ===
package model

import (
	"fmt"
	"strings"
)

type Candidates []string

// Candidates in human-readable format
func (cs Candidates) String() (s string) {
	var sb strings.Builder

	for i, candidate := range cs {
		sb.WriteString(
			fmt.Sprintf("%d) %s\n\n", i+1, candidate),
		)
	}

	return sb.String()
}

// Value returned in case of tries exhaustion
func (cs Candidates) Fallback() string {
	return cs[0]
}

=== File: ./tg-handler/model/model.go ===
package model

import (
	"context"
	"errors"
	"fmt"
	"log"
	"time"

	"tg-handler/carma"
	"tg-handler/conf"
	"tg-handler/memory"
	"tg-handler/prompts"
	"tg-handler/selectIdx"
	"tg-handler/tags"
)

// Constants
const (
	apiUrl       = "http://ollama:11434/api/generate"
	retryTime    = time.Minute
	waitTimeout  = 10 * time.Minute
	maxSelectTry = 10
	maxTagsTry   = 10
	maxCarmaTry  = 10
)

// Message abstraction
type Message interface {
	SenderProvider
	LineProvider
}

type SenderProvider interface {
	Sender() string
}

type LineProvider interface {
	Line() string
}

// Model errors
var (
	errGenFailed = errors.New("generation failed")
)

// LLM model
type Model struct {
	Config    *conf.BotConf
	Prompts   *prompts.Prompts
	Memory    *memory.Memory
	BotName   string
	ChatTitle string
}

func New(
	botConf *conf.BotConf,
	promptTemplates *conf.PromptTemplates,
	memory *memory.Memory,
	lastMsg Message,
	botName string,
	chatTitle string,
) *Model {
	var candidateNum = botConf.Main.CandidateNum

	// Format prompts from templates
	prompts := prompts.New(
		promptTemplates,
		memory, lastMsg, botName, chatTitle, candidateNum,
	)

	return &Model{
		Config:    botConf,
		Prompts:   prompts,
		Memory:    memory,
		BotName:   botName,
		ChatTitle: chatTitle,
	}
}

// Reacts to new message
func (m *Model) React(ctx context.Context) string {
	candidates := m.genCandidates(ctx)
	bestCandidate := m.selectBestCandidate(ctx, candidates)
	return bestCandidate
}

// Reflects on response
func (m *Model) Reflect(
	ctx context.Context,
	user string,
	reply Message,
) {
	var (
		botContacts = m.Memory.BotContacts
	)

	// Get contact to update
	botContact := botContacts.Get(user)

	// Update carma
	carmaUpdate := m.genCarmaUpdate(ctx, reply.Line())
	botContact.Carma.Apply(carmaUpdate)

	// Update persona
	tags := m.genTags(ctx, reply.Line())
	botContact.Tags = tags

	// Reset contacts
	botContacts.Set(user, botContact)
}

// Generates candidates
func (m *Model) genCandidates(ctx context.Context) []string {
	var (
		candidateNum = m.Config.Main.CandidateNum
		candidates   = make([]string, 0, candidateNum)
	)

	// Form request
	request := newRequest(m.Prompts.Response, m.Config)

	// Generate candidates
	for i := range candidateNum {
		tryStr := fmt.Sprintf("[model] generate (iter %d)", i+1)

		// Log start
		log.Printf("%s: %s", tryStr, "...")

		// Get new candidate
		candidate := sendRequestEternal(ctx, request)

		// Append to candidates
		candidates = append(candidates, candidate)

		// Log successs
		log.Printf("[model] candidate %d: %s", i+1, candidate)
	}

	return candidates
}

// Select the best candidate
func (m *Model) selectBestCandidate(
	ctx context.Context,
	candidates Candidates,
) string {
	const genType = "select index"

	// One candidate to be selected, return it
	if len(candidates) == 1 {
		return candidates[0]
	}

	// Format prompt
	prompt := prompts.FinFmtSelectPrompt(
		m.Prompts.Select, candidates,
	)
	// Form request
	request := newRequest(prompt, m.Config)

	// Try to select the best candidate
	for i := range maxSelectTry {
		tryStr := fmt.Sprintf("[model] select (try %d)", i+1)

		// Log start
		log.Printf("%s: %s", tryStr, "...")

		// Try to get select index
		selectStr := sendRequestEternal(ctx, request)
		selectIdx, err := selectIdx.New(selectStr, len(candidates))

		// Log success, return
		if err == nil {
			log.Printf("%s: %s", tryStr, selectIdx)
			return candidates[selectIdx]
		}

		// Log failure, continue
		log.Printf(
			"%s: %v: %s: %v", tryStr, errGenFailed, genType, err,
		)
	}

	// Fall back
	log.Println("[model] using fallback value for candidates")
	return candidates.Fallback()
}

// Generates unique tags
func (m *Model) genTags(
	ctx context.Context,
	replyLine string,
) tags.Tags {
	const genType = "tags"

	// Format prompt
	prompt := prompts.FinFmtTagsPrompt(m.Prompts.Tags, replyLine)
	// Form request
	request := newRequest(prompt, m.Config)

	for i := range maxTagsTry {
		tagsStr := fmt.Sprintf("[model] tags (try %d)", i+1)

		// Log start
		log.Printf("%s: %s", tagsStr, "...")

		// Get tags
		rawTags := sendRequestEternal(ctx, request)
		tags, err := tags.New(rawTags, m.Memory.Limits.Tags)

		// Log success, return
		if err == nil {
			log.Printf("[model] tags: %s", tags)
			return tags
		}

		// Log failure, continue
		log.Printf(
			"%s: %v: %s: %v", tagsStr, errGenFailed, genType, err,
		)
	}

	// Fall back
	log.Println("[model] using fallback value for tags")
	return tags.Fallback()
}

// Generates carma update
func (m *Model) genCarmaUpdate(
	ctx context.Context,
	replyLine string,
) carma.Update {
	const genType = "carma update"

	// Format prompt
	prompt := prompts.FinFmtCarmaPrompt(m.Prompts.Carma, replyLine)
	// Form request
	request := newRequest(prompt, m.Config)

	for i := range maxCarmaTry {
		tryStr := fmt.Sprintf("[model] carma update (try %d)", i+1)

		// Log start
		log.Printf("%s: %s", tryStr, "...")

		// Try to get carma update
		carmaUpdateStr := sendRequestEternal(ctx, request)
		carmaUpdate, err := carma.NewUpdate(carmaUpdateStr)

		// Log success, return
		if err == nil {
			log.Printf("[model] carma update: %s", carmaUpdate)
			return carmaUpdate
		}

		// Log failure, continue
		log.Printf(
			"%s: %v: %s: %v", tryStr, errGenFailed, genType, err,
		)
	}

	// Fall back
	log.Println("[model] using fallback value for carma update")
	return carma.Fallback()
}

=== File: ./tg-handler/model/ollama.go ===
package model

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"time"

	"tg-handler/conf"
)

// Ollama errors
var (
	ErrLoadEnvFailed = errors.New(
		"[model] failed to load $LLM_MODEL from environment",
	)
)

// Environment constant
var model = getEnv("LLM_MODEL", ErrLoadEnvFailed)

func getEnv(key string, err error) string {
	if value, ok := os.LookupEnv(key); ok {
		return value
	}

	log.Fatal(err)
	return ""
}

// Request to Ollama
type Request struct {
	Model        string                `json:"model"`
	Prompt       string                `json:"prompt"`
	Stream       bool                  `json:"stream"`
	Options      conf.OptionalSettings `json:"options"`
	SystemPrompt string                `json:"system,omitempty"`
	Context      []int                 `json:"context,omitempty"`
}

func newRequest(prompt string, botConf *conf.BotConf) *Request {
	return &Request{
		Model:        model, // Loaded from environment
		Prompt:       prompt,
		Stream:       false,
		SystemPrompt: botConf.Main.Role,
		Options:      botConf.Optional,
	}
}

// Response from Ollama
type Response struct {
	Model              string `json:"model"`
	CreatedAt          string `json:"created_at"`
	Response           string `json:"response"`
	Done               bool   `json:"done"`
	Context            []int  `json:"context,omitempty"`
	TotalDuration      int64  `json:"total_duration,omitempty"`
	LoadDuration       int64  `json:"load_duration,omitempty"`
	PromptEvalCount    int    `json:"prompt_eval_count,omitempty"`
	PromptEvalDuration int64  `json:"prompt_eval_duration,omitempty"`
	EvalCount          int    `json:"eval_count,omitempty"`
	EvalDuration       int64  `json:"eval_duration,omitempty"`
}

// Ollama errors
var (
	ErrMarshalFailed     = errors.New("[model] marshal request failed")
	ErrRequestFailed     = errors.New("[model] create request failed")
	ErrSendFailed        = errors.New("[model] send request failed")
	ErrInvalidStatus     = errors.New("[model] invalid status code")
	ErrDecodeFailed      = errors.New("[model] decode response failed")
	ErrRequestIncomplete = errors.New("[model] request not completed")
)

// Eternally sends request to API and logs error
func sendRequestEternal(ctx context.Context, request *Request) string {
	var (
		text string
		err  error
	)

	// Get text
	for {
		text, err = sendRequest(ctx, request)
		if err == nil {
			break
		}
		log.Printf("%v: %v", ErrSendFailed, err)
		time.Sleep(retryTime)
	}

	// Clean text
	log.Println("Raw text:", text)
	text = trimNoise(text)
	log.Println("Cleaned text:", text)

	return text
}

// Sends Ollama request
func sendRequest(ctx context.Context, request *Request) (string, error) {
	// Encode request body to JSON data
	jsonData, err := json.Marshal(request)
	if err != nil {
		return "", fmt.Errorf("%w: %v", ErrMarshalFailed, err)
	}

	// Make POST request with JSON data
	req, err := http.NewRequestWithContext(
		ctx, "POST", apiUrl, bytes.NewBuffer(jsonData),
	)
	if err != nil {
		return "", fmt.Errorf("%w: %v", ErrRequestFailed, err)
	}
	req.Header.Set("Content-Type", "application/json")

	// Set HTTP client
	client := &http.Client{Timeout: waitTimeout}
	resp, err := client.Do(req)
	if err != nil {
		return "", fmt.Errorf("%w: %v", ErrSendFailed, err)
	}
	defer resp.Body.Close()

	// Validate status code
	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return "", fmt.Errorf(
			"%w %d: %s", ErrInvalidStatus, resp.StatusCode, string(body),
		)
	}

	// Decode response body
	var response Response
	err = json.NewDecoder(resp.Body).Decode(&response)
	if err != nil {
		return "", fmt.Errorf("%w: %v", ErrDecodeFailed, err)
	}

	// Validate request completeness
	if !response.Done {
		return "", ErrRequestIncomplete
	}

	return response.Response, nil
}

=== File: ./tg-handler/model/trim.go ===
package model

import (
	"strings"
)

// Removes noise
func trimNoise(s string) string {
	s = trimThinkingTags(s)
	s = strings.TrimSpace(s)
	s = strings.Trim(s, "*")
	return s
}

// Smartly removes thinking blocks
func trimThinkingTags(s string) string {
	startTag := "<think>"
	endTag := "</think>"

	// PRIORITY: "Final Answer" comes AFTER the thought process.
	if endIdx := strings.LastIndex(s, endTag); endIdx != -1 {
		return s[endIdx+len(endTag):]
	}

	// FALLBACK: "Final Answer" comes BEFORE the thought process.
	if startIdx := strings.Index(s, startTag); startIdx != -1 {
		return s[:startIdx]
	}

	// No tags found
	return s
}

=== File: ./tg-handler/bot/helpers.go ===
package bot

import (
	"slices"
	"strings"

	tg "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// Gets admin identifier for bot
func (bot *Bot) getAdminDetector() func(*tg.Message, string) bool {
	admins := bot.Settings.AllowedChats.Usernames

	// Identifies if private sender is admin
	return func(msg *tg.Message, sender string) bool {
		if msg.Chat.IsPrivate() {
			return slices.Contains(admins, sender)
		}
		return false
	}
}

// Gets reply identifier for bot
func (bot *Bot) getReplyDetector() func(msg *tg.Message) bool {
	return func(msg *tg.Message) bool {
		var isReplied bool

		// Get replied message
		repliedMsg := msg.ReplyToMessage
		// Try to get replied user ID
		var repliedUserID int64
		if repliedMsg != nil {
			repliedUserID = repliedMsg.From.ID
		}

		// Check if bot is replied
		if repliedUserID == bot.ID {
			isReplied = true
		}

		return isReplied
	}
}

// Gets mention identifier for bot
func (bot *Bot) getMentionDetector() func(string) bool {
	// Identifies if text contains bot's @username
	return func(text string) bool {
		return strings.Contains(text, "@"+bot.UserName)
	}
}

// Gets mention modifier for bot
func (bot *Bot) getMentionModifier() func(string) string {
	// Substitutes bot's @username to first name in text
	return func(text string) string {
		return strings.ReplaceAll(text, "@"+bot.UserName, bot.FirstName)
	}
}

// Gets chat validator for bot
func (bot *Bot) getChatValidator() func(int64) bool {
	allowedCIDs := bot.Settings.AllowedChats.IDs

	// Identifies if chat has allowed ID
	return func(cid int64) bool {
		for _, allowedCID := range allowedCIDs {
			if cid == allowedCID {
				return true
			}
		}
		return false
	}
}

=== File: ./tg-handler/bot/bot.go ===
package bot

import (
	"context"
	"errors"
	"log"
	"path/filepath"

	tg "github.com/go-telegram-bot-api/telegram-bot-api/v5"

	"tg-handler/conf"
	"tg-handler/history"
	"tg-handler/memory"
	"tg-handler/messaging"
	"tg-handler/model"
)

// Bot errors
var (
	errAuthFailed = errors.New("[bot] authorization failed")
)

type Bot struct {
	API         *tg.BotAPI
	ID          int64
	UserName    string
	FirstName   string
	Conf        *conf.BotConf            // Bot config
	Settings    *conf.BotSettings        // Init config
	ChatQueues  history.SharedChatQueues // Preinit, shared, r-only
	UpdSignalCh chan<- any               // Signal update end
	History     *history.SafeBotHistory  // Chat histories
	Contacts    *history.SafeBotContacts // Chat agnostic contacts
}

func New(
	keyAPI string,
	iConf *conf.InitConf,
	h *history.History,
	updSignalCh chan<- any,
) *Bot {
	// Authorize as bot
	b, err := tg.NewBotAPI(keyAPI)
	if err != nil {
		log.Fatalf("%v: %v", errAuthFailed, err)
	}

	// Get bot names
	var (
		userName  = b.Self.UserName
		firstName = b.Self.FirstName
	)
	defer log.Printf("[bot] %s authorized", userName)

	// Get bot history and contacts
	data := h.Bots.Get(userName)
	history, contacts := data.History, data.Contacts

	// Get bot config path
	confPath := filepath.Join(
		iConf.Paths.BotsConfDir, userName+".json",
	)
	// Get bot config
	botConf := conf.MustLoadBotConf(confPath)

	// Return bot instance via pointer
	return &Bot{
		API:         b,
		ID:          b.Self.ID,
		UserName:    userName,
		FirstName:   firstName,
		Conf:        botConf,
		Settings:    &iConf.BotSettings,
		ChatQueues:  h.SharedChatQueues,
		UpdSignalCh: updSignalCh,
		History:     history,
		Contacts:    contacts,
	}
}

// Gets message info for bot
func (bot *Bot) getMessageInfo(
	msg *tg.Message,
) *messaging.MessageInfo {
	return messaging.NewMessageInfo(
		bot.API, msg,
		bot.getAdminDetector(),
		bot.getReplyDetector(),
		bot.getMentionDetector(),
		bot.getMentionModifier(),
		1,
	)
}

// Gets chat info for bot
func (bot *Bot) getChatInfo(
	msgInfo *messaging.MessageInfo,
) *messaging.ChatInfo {
	return messaging.NewChatInfo(
		msgInfo,
		bot.History,
		bot.ChatQueues, // Shared chat queues for public chats
		bot.getChatValidator(),
	)
}

// Starts bot
func (bot *Bot) Start(ctx context.Context) {
	// Prepare updates channel
	u := tg.NewUpdate(0)
	u.Timeout = 30
	updates := bot.API.GetUpdatesChan(u)

	// Handle updates until updates channel CLOSED or context DONE
	defer log.Printf("[bot] %s shut down gracefully", bot.UserName)
	for {
		select {
		case update, ok := <-updates:
			if !ok {
				log.Printf(
					"[bot] %s update channel closed", bot.UserName,
				)
				return
			}

			bot.handleUpdate(ctx, update)

		case <-ctx.Done():
			log.Printf(
				"[bot] %s received shutdown signal", bot.UserName,
			)
			return
		}
	}
}

// Handles update
func (bot *Bot) handleUpdate(ctx context.Context, upd tg.Update) {
	// Get message info and check if valid
	msgInfo := bot.getMessageInfo(upd.Message)
	if msgInfo == nil {
		return
	}

	// Get chat info and check if allowed
	chatInfo := bot.getChatInfo(msgInfo)
	if !chatInfo.IsAllowed {
		return
	}

	// Check if not triggered
	if !chatInfo.LastMsg.IsTriggering { // Save anyway
		chatInfo.History.AddToChatQueue(chatInfo.LastMsg)
		return
	}

	bot.handleMessage(ctx, chatInfo)
}

// Handles message in chat context
func (bot *Bot) handleMessage(
	ctx context.Context,
	chatInfo *messaging.ChatInfo,
) {
	log.Printf("[bot] %s got message", bot.UserName)

	// Record new message to history
	chatInfo.History.AddToBoth(chatInfo.LastMsg)

	// Create memory
	memory := memory.New(
		chatInfo.History, bot.Contacts,
		chatInfo.LastMsg, &bot.Settings.MemoryLimits,
	)

	// Create model
	model := model.New(
		bot.Conf, &bot.Settings.PromptTemplates, memory,
		chatInfo.LastMsg, bot.FirstName, chatInfo.Title,
	)

	go func() {
		// Reply
		replyInfo := bot.reply(ctx, model, chatInfo)
		// Record reply to history
		chatInfo.History.AddToBoth(replyInfo)

		// Reflect on reply
		bot.reflect(ctx, model, chatInfo.LastMsg.Sender(), replyInfo)

		// Send update signal
		bot.UpdSignalCh <- struct{}{}
	}()
}

// Replies to message in chat, return reply message info
func (bot *Bot) reply(
	ctx context.Context,
	model *model.Model,
	chatInfo *messaging.ChatInfo,
) *messaging.MessageInfo {
	var replyInfo *messaging.MessageInfo

	log.Printf(
		"[bot] %s replies to message", bot.UserName,
	)

	// Type until reply
	typingCtx, cancel := context.WithCancel(ctx)
	go messaging.Type(typingCtx, bot.API, chatInfo)
	defer cancel()

	// React via model
	text := model.React(ctx)

	// Reply
	reply := messaging.Reply(bot.API, chatInfo, text)
	replyInfo = bot.getMessageInfo(reply)

	return replyInfo
}

// Reflects on its reply
func (bot *Bot) reflect(
	ctx context.Context,
	model *model.Model,
	user string,
	replyInfo *messaging.MessageInfo,
) {
	log.Printf(
		"[bot] %s reflects on message", bot.UserName,
	)

	model.Reflect(ctx, user, replyInfo)
}

=== File: ./tg-handler/secret/secret.go ===
package secret

import (
	"errors"
	"log"
	"os"
	"strings"
)

const (
	envVar = "API_KEYS_FILE"
)

// Secret errors
var (
	ErrGetEnvFailed = errors.New(
		"[secret] failed to get '" + envVar + "' environment variable",
	)
	ErrReadFileFailed = errors.New(
		"[secret] failed to read '%s' file",
	)
	ErrEmptyKeysStr = errors.New(
		"[secret] got empty keys string from '%s' file",
	)
	ErrZeroKeys = errors.New(
		"[secret] got zero keys from '%s' file",
	)
)

// Loads API keys from environment variable or panics
func MustLoadAPIKeys() []string {
	// Get secret file from environment variable
	secretFile, ok := os.LookupEnv(envVar)
	if !ok {
		log.Fatal(ErrGetEnvFailed)
	}

	// Read secret file
	content, err := os.ReadFile(secretFile)
	if err != nil {
		log.Fatalf("%v: %v", ErrReadFileFailed, err)
	}

	// Get non-empty keys string
	keysStr := string(content)
	if strings.TrimSpace(keysStr) == "" {
		log.Fatal(ErrEmptyKeysStr)
	}

	// Split into raw lines by "\n"
	rawLines := strings.Split(keysStr, "\n")

	// Accumulate keys as cleaned lines
	var keys []string
	for _, rawLine := range rawLines {
		cleanedLine := strings.TrimSpace(rawLine)
		if cleanedLine != "" {
			keys = append(keys, cleanedLine)
		}
	}

	// Check if got non-zero keys
	if len(keys) < 1 {
		log.Fatal(ErrZeroKeys)
	}

	return keys
}

=== File: ./tg-handler/prompts/prompts.go ===
package prompts

import (
	"fmt"

	"tg-handler/conf"
	"tg-handler/memory"
)

// Abstract sender provider
type SenderProvider interface {
	Sender() string
}

// Prompts from formatted templates
type Prompts struct {
	Response string
	Select   string
	Tags     string
	Carma    string
}

// Formats all prompts from templates incrementally
func New(
	templates *conf.PromptTemplates,
	memory *memory.Memory,
	senderP SenderProvider,
	botName string,
	chatTitle string,
	candidateNum int,
) *Prompts {
	var (
		// Get templates
		responseTemplate = templates.Response
		selectTemplate   = templates.Select
		tagsTemplate     = templates.Tags
		carmaTemplate    = templates.Carma

		// Get tags limit
		tagsLimit = memory.Limits.Tags

		// Get sender username
		userName = senderP.Sender()
	)

	// Get names
	names := NewNames(botName, userName)

	return &Prompts{
		Response: fmtResponsePrompt(
			responseTemplate, memory, names, chatTitle,
		),
		Select: fmtSelectPrompt(
			selectTemplate, memory, names, candidateNum,
		),
		Tags: fmtTagsPrompt(
			tagsTemplate, memory, names, tagsLimit,
		),
		Carma: fmtCarmaPrompt(
			carmaTemplate, memory, names,
		),
	}
}

// Names type
type Names struct {
	Bot  string
	User string
}

func NewNames(bot string, user string) *Names {
	return &Names{
		Bot:  bot,
		User: user,
	}
}

// Finalizes select prompt formatting
func FinFmtSelectPrompt(prompt string, candidates []string) string {
	return fmt.Sprintf(prompt, candidates)
}

// Finalizes tags prompt formatting
func FinFmtTagsPrompt(prompt string, replyLine string) string {
	return fmt.Sprintf(prompt, replyLine)
}

// Finalizes carma prompt formatting
func FinFmtCarmaPrompt(prompt string, replyLine string) string {
	return fmt.Sprintf(prompt, replyLine)
}

// Formats response prompt
func fmtResponsePrompt(
	template string,
	memory *memory.Memory,
	names *Names,
	chatTitle string,
) string {
	var botName = names.Bot

	return fmt.Sprintf(template,
		botName, chatTitle, memory, names.Bot,
	)
}

// Formats select prompt incrementally
func fmtSelectPrompt(
	template string,
	memory *memory.Memory,
	names *Names,
	candidateNum int,
) string {
	var botName = names.Bot

	return fmt.Sprintf(template,
		botName, memory,
		"%s", // Response candidates placeholder
		candidateNum,
	)
}

// Formats tags prompt incrementally
func fmtTagsPrompt(
	template string,
	memory *memory.Memory,
	names *Names,
	lim int,
) string {
	var (
		botName  = names.Bot
		userName = names.User
		contact  = memory.BotContacts.Get(userName)
	)

	return fmt.Sprintf(template,
		userName, botName, memory,
		"%s", // Final response placeholder
		userName, contact.Tags,
		userName, lim,
	)

}

// Formats carma prompt incrementally
func fmtCarmaPrompt(
	template string,
	memory *memory.Memory,
	names *Names,
) string {
	var (
		botName  = names.Bot
		userName = names.User
		contact  = memory.BotContacts.Get(userName)
	)

	return fmt.Sprintf(template,
		userName, botName, memory,
		"%s", // Final response placeholder
		userName, contact.Carma,
	)
}

=== File: ./tg-handler/tags/tags.go ===
package tags

import (
	"errors"
	"log"
	"strings"
)

// Tags errors
var (
	errEmptyRawTagsString = errors.New(
		"[tags] empty raw tags string",
	)
	errZeroTags = errors.New(
		"[tags] zero tags",
	)
	errTagNoHashSign = errors.New(
		"[tags] tag does not start with '#'",
	)
)

// --- PUBLIC TAGS COLLECTION ---

type Tags []tag

// Parses string from LLM and accumulates unique tags from it
func New(s string, lim int) (Tags, error) {
	// Handle empty string
	if s == "" {
		return nil, errEmptyRawTagsString
	}

	var tags []tag

	// Get raw tags
	rawTags := strings.Fields(s)

	// Accumulate unique tags
	seen := make(map[tag]bool)
	for _, rawTag := range rawTags {
		// Try to get tag
		tag, err := newTag(rawTag)

		// Skip non-tags
		if err != nil {
			log.Println(err)
			continue
		}

		// Skip duplicates
		if seen[tag] {
			continue
		}

		// Add unique tag
		seen[tag] = true
		tags = append(tags, tag)

		// Stop on limit
		if len(tags) >= lim {
			break
		}
	}

	// Check if non-zero tags
	if len(tags) < 1 {
		return nil, errZeroTags
	}

	return tags, nil
}

// Tags in human-readable format
func (tags Tags) String() string {
	var sb strings.Builder
	for i, tag := range tags {
		if i > 0 {
			sb.WriteString(" ")
		}
		// String() appends '#' prefix
		sb.WriteString(tag.String())
	}
	return sb.String()
}

// Tags in machine-readable fromat
func (tags Tags) Serialize() string {
	var sb strings.Builder
	for i, tag := range tags {
		if i > 0 {
			sb.WriteString(" ")
		}
		// string() bypasses String() method not adding '#' prefix
		sb.WriteString(string(tag))
	}
	return sb.String()
}

// Tags from machine-readable format
func DeserializeTags(s string) Tags {
	if s == "" {
		return nil
	}

	// Get raw tags
	rawTags := strings.Fields(s)

	// Accumulate tags casted from raw tags
	tags := make(Tags, 0, len(rawTags))
	for _, rawTag := range rawTags {
		// Cast directly with trust in type check
		tag := tag(rawTag)
		// Append to tags
		tags = append(tags, tag)
	}

	return tags
}

func Fallback() Tags {
	return Tags{"unknown"}
}

// --- PRIVATE TAGS TYPE ---

type tag string

// Tag starts with '#': dropped for memory, implied for printing
func newTag(s string) (tag, error) {
	if strings.HasPrefix(s, "#") {
		return tag(s[1:]), nil
	}
	return "", errTagNoHashSign
}

// Tag in human-readable format
func (t tag) String() string {
	return "#" + string(t)
}

=== File: ./tg-handler/go.sum ===
github.com/go-telegram-bot-api/telegram-bot-api/v5 v5.5.1 h1:wG8n/XJQ07TmjbITcGiUaOtXxdrINDz1b0J1w0SzqDc=
github.com/go-telegram-bot-api/telegram-bot-api/v5 v5.5.1/go.mod h1:A2S0CWkNylc2phvKXWBBdD3K0iGnDBGbzRpISP2zBl8=
github.com/google/go-cmp v0.7.0 h1:wk8382ETsv4JYUZwIsn6YpYiWiBsYLSJiTsyBybVuN8=
github.com/google/go-cmp v0.7.0/go.mod h1:pXiqmnSA92OHEEa9HXL2W4E7lf9JzCmGVUdgjX3N/iU=
golang.org/x/sync v0.19.0 h1:vV+1eWNmZ5geRlYjzm2adRgW2/mcpevXNg50YZtPCE4=
golang.org/x/sync v0.19.0/go.mod h1:9KTHXmSnoGruLpwFjVSX0lNNA75CykiMECbovNTZqGI=
golang.org/x/text v0.32.0 h1:ZD01bjUt1FQ9WJ0ClOL5vxgxOI/sVCNgX1YtKwcY0mU=
golang.org/x/text v0.32.0/go.mod h1:o/rUWzghvpD5TXrTIBuJU77MTaN0ljMWE47kxGJQ7jY=
google.golang.org/protobuf v1.36.11 h1:fV6ZwhNocDyBLK0dj+fg8ektcVegBBuEolpbTQyBNVE=
google.golang.org/protobuf v1.36.11/go.mod h1:HTf+CrKn2C3g5S8VImy6tdcUvCska2kB7j23XfzDpco=

=== File: ./tg-handler/carma/carma.go ===
package carma

import (
	"errors"
	"fmt"
)

const (
	Min = -100
	Max = 100
)

// Carma errors
var (
	ErrCarmaOOB      = errors.New("[carma] carma out of bounds")
	ErrCarmaBelowMin = fmt.Errorf("below minimum value of %d", Min)
	ErrCarmaOverMax  = fmt.Errorf("over maximum value of %d", Max)

	ErrCarmaUpdateOOV = errors.New(
		"[carma] carma update out of variants",
	)
)

type Carma int

func New(n int) (*Carma, error) {
	var err = ErrCarmaOOB

	// Abide bounds
	if n < Min {
		return nil, fmt.Errorf("%w: %v", err, ErrCarmaBelowMin)
	}
	if n > Max {
		return nil, fmt.Errorf("%w: %v", err, ErrCarmaOverMax)
	}

	c := Carma(n)
	return &c, nil
}

type Update int

const UpdateDelta = 10
const (
	UpdateNegative Update = -UpdateDelta
	UpdateNeutral         = 0
	UpdatePositive        = UpdateDelta
)

// To string
var UpdateTag = map[Update]string{
	UpdateNegative: "-",
	UpdateNeutral:  "=",
	UpdatePositive: "+",
}

func (u Update) String() string {
	return UpdateTag[u]
}

// From string
func NewUpdate(s string) (Update, error) {
	switch s {
	case "-":
		return UpdateNegative, nil
	case "=":
		return UpdateNeutral, nil
	case "+":
		return UpdatePositive, nil
	default:
		return UpdateNeutral, ErrCarmaUpdateOOV
	}
}

// Apply carma update
func (c *Carma) Apply(u Update) {
	// Calculate new value
	newVal := int(*c) + int(u)

	// Abide saturation
	if newVal < Min {
		*c = Carma(Min)
		return
	}
	if newVal > Max {
		*c = Carma(Max)
		return
	}

	// Set new value
	*c = Carma(newVal)
}

// Value used in case of generation failure
func Fallback() Update {
	return UpdateNeutral
}

=== File: ./install.sh ===
# Install dependencies
sudo apt update && sudo apt install -y --no-install-recommends \
   curl \
   gnupg2

# Get NVIDIA repository
curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey \
    | sudo gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg
curl -s -L https://nvidia.github.io/libnvidia-container/stable/deb/nvidia-container-toolkit.list \
    | sed 's#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g' \
    | sudo tee /etc/apt/sources.list.d/nvidia-container-toolkit.list
sudo apt-get update


# Install NVIDIA Container Toolkit
sudo apt-get install -y nvidia-container-toolkit

# Configure Docker to use NVIDIA driver
sudo nvidia-ctk runtime configure --runtime=docker
sudo systemctl restart docker

=== File: ./docker-compose.yml ===
services:
  tg-handler:
    image: veotri/tg-handler:v0.5.1
    build:
      context: .
      dockerfile: tg-handler/Dockerfile
    environment:
      API_KEYS_FILE: /run/secrets/api_keys
      LLM_MODEL: ${LLM_MODEL}
    volumes:
      - ./confs:/app/confs:ro
      - ./history:/app/history 
    networks:
      - ollama-network
    secrets:
      - api_keys
    depends_on:
      ollama:
        condition: service_healthy

  ollama:
    image: ollama/ollama:latest
    container_name: ollama
    volumes:
      - ollama-data:/root/.ollama
    networks:
      - ollama-network
    ports:
      - "11435:11434"
    restart: unless-stopped
    deploy:
      resources:
        reservations:
          devices:
            - driver: nvidia
              count: all
              capabilities: [gpu]
    entrypoint:
      - /bin/sh
      - -c
      - |
        # Stop script on error
        set -e

        # --- START SERVER ---
        echo 'Starting server...'
        ollama serve &
        PID=$$!

        # Wait until server responds
        echo 'Waiting for Ollama API...'
        while ! ollama list > /dev/null 2>&1; do
            sleep 1
        done
        # --- START SERVER END ---

        # --- TRY PULLING 5 TIMES ---
        echo "Pulling model: ${LLM_MODEL}..."
        n=0
        until [ "$$n" -ge 5 ]
        do
           echo "Attempt $((n+1))/5 to pull model..."
           ollama pull ${LLM_MODEL} && break
           n=$$(($$n+1))
           echo "Pull failed. Retrying in 10 seconds..."
           sleep 10
        done
        
        # Check if failed
        if [ "$$n" -eq 5 ]; then
           echo "Failed to pull model after 5 attempts."
           exit 1
        fi
        # --- TRY PULLING 5 TIMES END ---

        # --- LOAD MODEL ---
        echo 'Loading model into memory...'
        echo 'no think, dot' | ollama run ${LLM_MODEL} > /dev/null
        
        # Report success
        echo 'Model loaded successfully!'
        wait $$PID
        # --- LOAD MODEL END ---
    healthcheck: # Wait for 3 hours and 5 minutes
      test:
        - CMD-SHELL
        - ollama ps | grep -q ${LLM_MODEL}
      interval: 10s
      timeout: 10s
      retries: 1000
      start_period: 300s

volumes:
  ollama-data:

networks:
  ollama-network:

secrets:
  api_keys:
    file: api_keys.txt

=== File: ./.gitignore ===
history
api_keys.txt

=== File: ./list.txt ===

